---
title:  "[컴퓨터 구조] 컴퓨터 구조와 운영체제 1"
excerpt: "컴퓨터 구조 / 데이터 표현 / 명령어 구조"
categories:
  - ComputerArchitecture
tags:
  - [공부용]

toc: true
toc_label: "List"
toc_icon: "bars"
toc_sticky: true
 
date: 2025-11-25
last_modified_at: 2025-12-25
---

<br>

# <span style="color:rgb(0, 180, 180)">간단히 알아보는 컴퓨터 구조와 운영체제</span>
<span style="font-size: large">해당 포스팅은 **혼자 공부하는 컴퓨터구조+운영체제**를 기반으로 작성하는 글입니다.  
총 15개의 챕터로 이루어져 있으며 적당히 분배하여 포스팅하겠습니다.</span>

## ✔️먼저읽기✔️
**Chapter 1.**  
<u>컴퓨터 구조</u>의 **필요성과 핵심 부품**들을 살펴봅시다.

**Chapter 2.**  
<u>데이터</u>의 **정보 단위, 2진법과 16진법, 인코딩**에 대해 알아봅시다.

**Chapter 3.**  
<u>명령어</u>의 **구조와 고급 언어/저급 언어**에 대해 알아봅시다.

## 참고자료
강민철. **『혼자 공부하는 컴퓨터구조 + 운영체제』**, 한빛미디어(2022년 출간) 

<br>

# Chapter 1

## 개발자의 기초 역량 컴퓨터의 구조.
<u>컴퓨터 구조</u>는 컴퓨터가 **어떻게 동작**하는지를 들여다 보는 것 입니다.  
개발자가 프로그램을 만들 때는 **성능/비용/용량** 등을 고려하고  
오류가 발생했을 때 **문제의 원인을 해결**하는데 도움이 됩니다.

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 성능도 좋고 비용도 저렴하며 용량까지 합리적인 프로그램이란 존재하지 않습니다.
적당한 타협이 필요하죠. 좋은 개발자는 합리적인 요건을 충족시키며 문제 해결 능력을 갖춘 사람입니다.</span>
</div>

## 컴퓨터의 핵심부품.
컴퓨터의 주요 부품은 4가지로 분류했습니다.

<u>중앙처리장치</u>는 **두뇌의 역활**을 담당합니다.  
[부품 중 **CPU**에 해당]  

<u>주기억장치</u>는 **컴퓨터 실행 시 실시간 정보를 담는** 장치입니다.  
[부품 중 **RAM**에 해당]  

<u>보조기억장치</u>는 **저장 공간**을 담당합니다.  
[부품 중 **SSD/HDD**에 해당]  

<u>입출력장치</u>는 **사용자와의 상호작용**을 담당합니다.  
[부품 중 **모니터와 마우스, 키보드, 스피커 등**에 해당]  
<br>

![Image](https://github.com/sshoon5558/ImagePath/blob/main/unamed.png?raw=true)  

### CPU
CPU는 주요 구성 요소 3개로 **ALU, 제어장치, 레지스터**가 있습니다.  
<br>

**Arithmetic Logic Unit(산술논리연산장치)**  
- 컴퓨터의 계산 영역을 담당합니다.

**Control Unit(제어장치)**  
- 제어신호를 내보내거나 명령어를 해석하는 장치입니다.  
[대표적인 제어신호로 메모리 읽기/쓰기가 있습니다.]

**Register(레지스터)**  
- CPU 내부의 임시 저장 장치입니다.

### 메모리
메모리는 **명령어와 데이터**의 저장공간입니다.  
메모리에 접근하기 위해 **주소**를 사용합니다.  
<br>
**<span style="color:rgb(0, 180, 180)">특징 1</span>**, 메모리는 <u>전원이 차단</u>되면 모든 정보가 사라지는 **휘발성 성질**을 갖고 있습니다.  
<br>
**<span style="color:rgb(0, 180, 180)">특징 2</span>**, 메모리는 <u>실행 정보를 관리</u>하므로 **읽고 쓰는 속도가 빠르지만 비용이 비쌉**니다.  
[이는 실행 프로그램의 정보는 메모리가 갖는게 적합하다는 의미]  

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 메모리를 비유하자면<br>
 1. 네비게이션의 <u>경유지 또는 도착지</u>라 할 수 있습니다.<br>
 2. 도착지나 경유지를 찾아가려면 <u>주소를 먼저 입력</u>합니다.<br>
 3. 메모리의 데이터(도착지)에 <u>새로운 주소</u>가 저장되어 있을 수 있습니다. 이는 마치 경유지와 같죠!</span>
</div>

**\<대략적인 흐름\>**  
<br>
[첫번째 명령어: 10번지와 12번지를 더해라]
<br>

1. **제어장치(읽기 신호)** - `메모리에서 얻어온 명령어를 레지스터에 저장.`
2. **제어장치(해석)** - `가져온 명령어를 해석.`
3. **제어장치(읽기 신호)** - `메모리(10번지, 12번지) 데이터 확보 후, 각각 레지스터에 저장.`
4. **ALU(연산)** - `결과 값을 레지스터에 저장.`  

<br>
[두번째 명령어: 20번지에 저장해라]
<br>

1. **제어장치(읽기 신호)** - `메모리에서 얻어온 명령어를 레지스터에 저장.`
2. **제어장치(해석)** - `가져온 명령어를 해석.` 
3. **제어장치(쓰기 신호)** - `레지스터에 저장된 결과 값을 연산된 메모리(20번지)에 갱신.`  


### 보조기억장치
앞선 <u>메모리의 특징들</u>의 **약점을 보안**하기 위한 장치입니다.  
주로 <u>설치된 프로그램</u>의 **정보를 저장**합니다.  

보조기억장치로는 **하드 디스크, SSD, USB 메모리, DVD, CD-ROM 등** 있습니다.  
<br>
**<span style="color:rgb(0, 180, 180)">특징 1</span>**&nbsp; 보조기억장치는 **저장공간이 크고 비휘발성 성질**을 가집니다.  
[즉, 전원이 꺼져도 프로그램 정보를 보관]  
<br>
**<span style="color:rgb(0, 180, 180)">특징 2</span>**&nbsp; 보조기억장치는 **읽고 쓰기 성능이 메모리에 비해 부족, 비용은 상대적으로 저렴**합니다.
<br>
<br>

### 입출력장치
**마이크, 스피커, 프린터, 마우스, 키보드**와 같이 컴퓨터 외부에서 신호를 주고받는 장치입니다.
<br>

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 사실 보조기억장치도 외부 연결로 취급할 수 있기 때문에 입출력장치로 볼 수도 있습니다.<br>
그렇기 때문에 이를 합쳐 <u>주변장치로 통칭</u>하기도 합니다.</span>
</div>

### 메인보드와 시스템 버스
<u>메인보드</u>는 여러 컴퓨터 부품을 **연결하는 슬롯과 단자**가 있습니다.  
<br>
메인보드 내부의 <u>버스라는 통로</u>를 통해 연결 부품들은 **정보를 전송**합니다.  
이는 <u>시스템 버스</u>라 부르고 **제어버스/주소버스/데이터버스**로 구분합니다.

**제어버스**는 읽기/쓰기와 같은 제어 신호를 보낼 때  
**주소버스**는 주소를 주고 받을 때  
**데이터버스**는 데이터와 명령어를 주고 받을 때  

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 만약, 특정 주소에 데이터를 쓰고 싶다면<br>
1. 데이터를 보낸다. (데이터버스)<br>
2. 읽을지 쓸지 결정한다. (제어버스)<br>
3. 어디에 저장할지 결정한다. (주소버스)<br><br>
각각의 정보를 전용 통로를 통해 보냅니다.</span>
</div>

# Chapter 2

## 데이터의 숫자 표현
컴퓨터의 모든 데이터는 **0, 1**로 표현합니다.  
[즉, 전기신호의 불이 On/Off 인지를 나타냄]

### 정보의 단위
<u>비트</u>는 **0과 1**을 표현하는 기본 단위(전구 1개)  
<u>바이트</u>는 **비트 8개**를 묶은 단위(전구 8개)  
[모든 전구 상태의 표현 가짓수는 2<sup>8</sup> = 256]  

|-:|-:
| 1byte | 8bit 
| 1KB | 1000byte 
| 1MB | 1000KB 
| 1GB | 1000MB

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 1024 단위로 많이 사용하는데 이는 KiB, MiB, GiB 표현 방식입니다.</span>
</div>

<br>

<u>워드</u>는 CPU가 한 번의 처리할 수 있는 **데이터양**입니다.  
[워드당 16비트, 32비트, 64비트 등]
<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 대부분의 보급 컴퓨터는 64비트를 사용합니다.</span>
</div>

### 2진법
<u>2진법</u>은 **컴퓨터의 숫자 표현 방식**입니다.(0, 1)  
<u>10진법</u>은 1~9를 사용하는 **인간의 숫자 표현 방식**입니다.  

즉, n진법은 n개의 숫자를 갖는 숫자 표현 방식이겠죠?

### 2의 보수
<u>2의 보수</u>는 **2진법의 음수 표현 방식**입니다.  

![Image](https://github.com/sshoon5558/ImagePath/blob/main/unnamed.png?raw=true)

간단 계산법은 위와 같지만 수식으로 풀자면 다음과 같습니다.  
[2의 보수는 <u>표현 가능 값</u> 보다 **큰 2<sup>n</sup> 값을 뺀** 결과 값.]

> 4bit로 표현 가능한 범위 0~15  
> 표현 가능 값 15보다 큰 2<sup>n</sup> 값은 16  
> 
> 결과 값: 16 - 5(0101<sub>2</sub>) = 11(1011<sub>2</sub>)

그렇다면 어떻게 음수인지 구별하죠?  
`보통 가장 앞 비트를 부호 플래그로 봅니다. 0 - 양수, 1 - 음수`
<br>

그렇다면 왜 2의 보수를 써야할까요?  
`2의 보수 방식을 사용하면 음수 값을 [합 연산 / 2의 보수 전환]만으로 연산할 수 있습니다.`  
`달리 말하면 +연산으로 -를 처리할 수 있는 이점이 큽니다.`
<br>

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 3(0011<sub>2</sub>)과 -5(1011<sub>2</sub>)을 더해보세요!<br> 
  부호 비트까지 확장하면 3(00011<sub>2</sub>), -5(11011<sub>2</sub>) 결과는 14(11110<sub>2</sub>).<br>
  이를 2의 보수를 취하면 2가 나옵니다.<br>
  즉, 11110<sub>2</sub>은 -2인 것이죠! </span>
</div>

### 16진법
2진법은 너무 적은 정보를 담고 있습니다.  

`4byte: 01011001 00011010 11010011 10111111`  
난잡한 바코드같지 않나요?  

16이란 수는 2<sup>4</sup>, 총 **4개의 bit를 표현 가능**합니다.  
이를 숫자와 알파벳을 결합해 16를 표현한다면?  
`0 ~ 9, A(10), B(11), C(12), D(13), E(14), F(15). 총 16개`  

바코드 같던 수를 16진법으로 다시 표현하면?  
`4byte": 59 1A D3 BF`  

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 정보의 양을 압축시키니 훨씬 보기 편해졌습니다!</span>
</div>

## 데이터의 문자 표현
<u>인간 문화 언어</u>(영어/한국어 등)들은 **인코딩/디코딩** 과정으로 <u>컴퓨터 언어</u>와 변환합니다.  

**인코딩과 디코딩**  
이는 **컴퓨터의 표현 숫자**와 **인간의 문자 집합**을 단순히 <u>대응한 것</u>에 대한 이야기입니다.  
대표적으로 **아스키 코드, 유니코드**가 있습니다.

### 아스키코드
해당 표준은 7비트, 즉 **128개의 문자(알파벳, 숫자, 특문) 표현 가능**합니다.  
[1bit는 패리티 비트(오류 검출용)로 사용]

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 하지만 1byte를 사용하므로 다른 언어, 집합 표현이 부족합니다. </span>
</div>

![image](https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/ASCII-Table.svg/1107px-ASCII-Table.svg.png?20221024154404)

### EUC-KR
물론 **한글 인코딩**도 있습니다.  
이는 한 글자를 **2byte(16비트)로 표현**합니다.  

인코딩 방식은 **완성형과 조합형** 두 가지 존재합니다.

**<span style="color:rgb(0, 180, 180)">완성형</span>**&nbsp; **글자 하나를 통째로 매핑**하는 방식입니다.  
**<span style="color:rgb(0, 180, 180)">조합형</span>**&nbsp; **초성, 중성, 종성에 비트열을 할당**합니다.  
[정렬과 검색 작업에 취약하여 현재는 거의 사용되지 않음]

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 '쀍'과 같은 미사용 글자를 제외한 2350자 정도 표현 가능합니다. </span>
</div>
이후 CP949로 확장됐지만, 유니코드의 등장으로 대부분 넘어갔습니다.

### 유니코드
다른 언어 인코딩을 지원하지 않은 경우 **글자가 깨지거나 볼 수 없게** 됩니다.  
유니코드는 <u>전 세계 모든 문자</u>를 하나로 **통합하여** 해결합니다.  

### UTF-8
 UTF의 약자는 **Unicode Transformation Format**입니다.  
즉, 유니코드 **정보를 담는 방식**입니다.    
숫자는 **인코딩 단위**(8bit, 16bit, 32bit)를 뜻합니다.

**<span style="color:rgb(0, 180, 180)">UTF-8</span>**&nbsp; 1~4byte(가변)  
[영어는 1byte, 한글은 3byte]

**<span style="color:rgb(0, 180, 180)">UTF-16</span>**&nbsp; 2, 4바이트(가변)  
[Java 초기 설계에 UTF-16을 채택]

**<span style="color:rgb(0, 180, 180)">UTF-32</span>**&nbsp; 4byte(고정)  
[단순하지만 저장 효율이 떨어짐]

대부분 <u>1byte 체계</u>(아스키코드, 마크다운 등)와도 **호환 가능**하고 **가변에 능한** UTF-8을 사용합니다.  

<br>

# Chapter 3
## 소스 코드와 명령어
여태까지 컴퓨터와 인간의 표현 방식을 배웠습니다.  
하지만 **컴퓨터는 어떻게 동작**할까요?

우리는 명령을 실행하기 위해 인간의 문법인 **프로그래밍 언어**를 사용합니다.  
[대표적인 C, C++, Python, Java]

이를 컴퓨터가 어떻게 이해하죠?  
인간의 명령과 0과 1의 관계를 어떻게 정의하죠?  

### 기계어
컴퓨터의 설계는 **0과 1의 정보만**으로 설계됐습니다.  
하지만 0과 1로 무엇을 할 수 있는 지는 모르죠.

**이를 정의한 것이 기계어**입니다.  
<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 이제 기계어를 이해할 수 있도록 <u>번역</u>해야겠죠? </span>
</div>

<br>

### 고급언어와 저급언어
<u>저급언어</u>는 0과 1로 구성된 **기계어를 인간의 언어로 번역**한 것입니다.  
<u>고급언어</u>는 **저급언어의 명령들을 모듈화**한 것입니다.

**<span style="color:rgb(0, 180, 180)">고급언어</span>**&nbsp;  프로그래밍 언어(C, C+, Python, Java 등)

```c
<stdio.h>

int main()
{
	printf("Hello world");
	return 0;
}
```

[C언어 - printf함수 안에는 수많은 어셈블리 코드가 작동]

<br>

**<span style="color:rgb(0, 180, 180)">저급언어</span>**&nbsp;  기계어, 어셈블리어

```nasm
push rbp
mov rbp, rsp
pop rbp
```

[어셈블리어 - push rbp는 기계어 0101 0101 해당]

<br>

<u>컴퓨터의 핵심 역활</u>은 **데이터의 읽기, 쓰기, 연산**입니다.  
<u>사용자</u>는 데이터의 선정방식, 연산 방식 등 수많은 **방법을 제시**하죠.

저급언어는 컴퓨터에 가장 근접한 번역어이지만  
가독성이, 편리한 문법 등 대다수 개발자들은 프로그래밍 언어를 사용합니다.  

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 하지만 어셈블리어를 다룰 줄 안다면 버그/오류를 찾기위해 컴퓨터의 동작을 확인해 원인을 파악할 수도 있겠죠? </span>
</div>

<br>

### 컴파일 언어와 인터프리터 언어
프로그래밍 언어는 저급언어로 변환이 되어야 컴퓨터가 수행가능합니다.  
이 과정에서 <u>고급언어에서 저급언어로</u> **변환하는 방식**입니다.  

<u>컴파일 언어</u>는 **소스코드를 기계어로 변환**합니다.  
<u>컴파일 완료 시</u> 소스코드는 컴퓨터가 이해 가능한 **목적코드로 변환**합니다.  
컴파일 수행 도구인 <u>컴파일러</u>는 **최적화, 문법 검사, 기계어로 변환 등을 수행**합니다.  
[하나라도 오류나면 컴파일 실패]

<u>인터프리터 언어</u>는 소스코드가 **한 줄씩 실행**됩니다.  
오류가 있어도 **오류 직전까지 실행**됩니다.  

<br>

**컴파일 언어 / 인터프리터 언어 차이점**  

|  | 컴파일 언어 | 인터프리터 언어
|:-|:-|:-
| **번역시점** | 실행 전 | 실행 시
| **목적파일** | 생성 | 미생성
| **장점** | 실행속도가 빠름 | 코드 수정 후 즉시 확인
| **대표언어** | C, C++ | Python

<br>

**컴파일 언어 특징**  
실행 시 컴파일 언어가 기계어로 변환하는 과정을 넘겨 **속도가 빠름**니다.  
하지만 파일이 클 수록 **빌드 시간**도 상당히 **오래 걸립**니다.  
즉, <u>실행속도나 성능을 중점</u>으로 둔 게임, VFX 등은 **C, C++, C#**을 주로 사용합니다.

**인터프리터 언어 특징**  
코드 수정으로 <u>즉각적인 결과</u>를 본다면 **작업속도 효율이 높아**집니다.  
즉, <u>작업속도를 중점</u>으로 둔 데이터 분석, 웹 서버, 자동화 툴 등은 **Python**을 주로 사용합니다.

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 현대의 프로그래밍 언어는 컴파일과 인터프리터 언어의 경계가 모호한 경우가 많습니다.<br>python도 컴파일을 합니다. [대표적으로 .pyc파일]</span>
</div>
<br>
**목적파일과 실행파일**  
목적파일에서 **링킹과정**을 거치면 **실행파일**이 됩니다.  
[윈도우의 .exe확장자가 대표적인 실행파일]

<u>여러 개로 나뉜 목적파일들</u>을 **하나로 연결하는 과정**을 <u>링킹</u>이라고 합니다.  

<div class="notice" style="padding: 0.5em; text-align: center; font-weight: bold;">
  <span style="font-size: medium;">🌠 참고로 빌드는 컴파일을 포함하여 실행 파일을 만들기 위한 모든 과정을 포함한 상위 개념입니다.</span>
</div>

## 명령어의 구조
우리가 작성한 명령어의 구조는 어떨까요?

### 연산 코드와 오퍼랜드
<u>명령어</u>는 연산자인 **연산 코드(Opcode)**와 피연산자인 **오퍼랜드(Operand)**로 구성됩니다.

**<span style="color:rgb(0, 180, 180)">연산코드</span>**&nbsp; CPU에서 수행되는 **연산 기능**입니다.

**<span style="color:rgb(0, 180, 180)">오퍼랜드</span>**&nbsp; 연산에 **사용할 데이터** 또는 **데이터가 저장된 위치 정보**입니다.  
[어셈블리어 명령어인 `push rbp`에서 <u>push</u>는 **연산 코드**이며, <u>rbp</u>는 **오퍼랜드**에 해당]

### 연산 코드의 주요 유형
연산 코드는 기능에 따라 크게 네 가지로 분류합니다.

- **데이터 전송**: move, store, load, push, pop
- **산술/논리 연산**: add, subtract, multiply, divide, increment, decrement, and, or, not, compare
- **제어 흐름 변경**: call, return, jump, conditional jump
- **입출력 제어**: read, write

![alt text](/assets/images/Instruction Format.jpg)

## 주소 지정 방식
<u>오퍼랜드 필드에 담긴 정보</u>를 이용해 **유효 주소를 결정하는 방법**입니다.  
[제한된 명령어 비트로 메모리에 접근하는 방식들]

**Immediate Addressing(즉시)**
- <u>연산에 사용할 데이터</u>를 **즉시 명시**합니다.  
[메모리나 레지스터를 찾을 필요가 없어 속도가장 빠르지만, 표현 데이터 크기가 제한]  
<br>

**Direct Addressing(직접)**
- <u>데이터가 저장된 메모리의 유효 주소</u>를 **직접 가리킵**니다.  
[유효 주소를 표현하는 필드 크기가 연산 코드만큼 줄어 표현 가능한 주소 범위가 좁음]  
<br>

**Indirect Addressing(간접)**
- <u>유효 주소가 저장</u>된 **메모리의 주소(간접적)**를 기입합니다.  
[메모리 접근이 두 번 이상 발생해 속도가 상대적으로 느림]  
<br>

**Register Addressing(레지스터)**
- 연산에 <u>사용할 데이터</u>가 **CPU 내부 레지스터**에 **저장**된 방식입니다.  
[CPU 내부 자원을 이용하여 직접 주소 지정 방식보다 처리가 빠름]  
<br>

**Register Indirect Addressing(레지스터 간접)**
- <u>데이터의 유효 주소</u>를 **CPU 내부 레지스터**에 **저장**한 방식입니다.  
[레지스터에 유효주소가 있어 메모리 접근 횟수가 간접 주소 지정 방식보다 적음]  
<br>

![alt text](/assets/images/Addressing Mode.jpg)

# 번외
## 스택과 큐
<u>Stack</u>은 **후입선출(LIFO)** 구조입니다.  
데이터 관리를 위해 **Push**와 **Pop** 연산을 사용합니다.

<u>Queue</u>는 **선입선출(FIFO)** 구조입니다.  
<u>먼저 들어간 데이터</u>가 **먼저 나오는 순서**를 따릅니다.

<hr>

<div class="notice--info" style="font-weight: normal;">
  <span style="font-size: medium;">✨개인 공부 글입니다! 언제든지 질문/지적 해주세요!✨</span>
</div>